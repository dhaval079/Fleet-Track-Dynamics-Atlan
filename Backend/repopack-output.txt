This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-10-15T09:27:35.788Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
.gitignore
package.json
README.md
src/app.js
src/controllers/adminController.js
src/controllers/authController.js
src/controllers/bookingController.js
src/controllers/driverController.js
src/controllers/userController.js
src/controllers/vehicleController.js
src/middleware/adminMiddleware.js
src/middleware/authMiddleware.js
src/middleware/errorHandler.js
src/models/Booking.js
src/models/Driver.js
src/models/User.js
src/models/Vehicle.js
src/routes/adminRoutes.js
src/routes/authRouter.js
src/routes/bookingRoutes.js
src/routes/driverRoutes.js
src/routes/userRoutes.js
src/routes/vehicleRoutes.js
src/services/pricingService.js
src/services/trackingService.js
src/websockets/trackingSocket.js
test.js

================================================================
Repository Files
================================================================

================
File: .gitignore
================
# Ignore node_modules directory
node_modules/

# Ignore environment variable files
.env

# Ignore log files
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Ignore lock files (if you're using npm, not yarn)
package-lock.json

# Ignore compiled output
dist/
build/

# Ignore VSCode settings
.vscode/

# Ignore temporary files
*.tmp
*.log
.DS_Store
Thumbs.db

# Ignore test coverage directory
coverage/

================
File: package.json
================
{
  "name": "atlan-backend",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start": "nodemon src/app.js",
    "dev": "nodemon src/app.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "bcrypt": "^5.1.1",
    "bcryptjs": "^2.4.3",
    "body-parser": "^1.20.3",
    "cookie-parser": "^1.4.7",
    "cors": "^2.8.5",
    "dotenv": "^16.4.5",
    "express": "^4.21.1",
    "express-async-handler": "^1.2.0",
    "json2csv": "^6.0.0-alpha.2",
    "jsonwebtoken": "^9.0.2",
    "mongoose": "^8.7.1",
    "node": "^20.18.0",
    "redis": "^4.7.0",
    "repopack": "^0.1.42"
  },
  "devDependencies": {
    "nodemon": "^3.1.7"
  }
}

================
File: README.md
================
# Project Structure
backend/
│
├── src/
│   ├── config/
│   │   ├── database.js
│   │   ├── environment.js
│   │   └── redis.js
│   │
│   ├── controllers/
│   │   ├── authController.js
│   │   ├── userController.js
│   │   ├── driverController.js
│   │   ├── bookingController.js
│   │   ├── vehicleController.js
│   │   ├── trackingController.js
│   │   ├── pricingController.js
│   │   └── adminController.js
│   │
│   ├── models/
│   │   ├── User.js
│   │   ├── Driver.js
│   │   ├── Booking.js
│   │   ├── Vehicle.js
│   │   ├── Location.js
│   │   └── Payment.js
│   │
│   ├── routes/
│   │   ├── authRoutes.js
│   │   ├── userRoutes.js
│   │   ├── driverRoutes.js
│   │   ├── bookingRoutes.js
│   │   ├── vehicleRoutes.js
│   │   ├── trackingRoutes.js
│   │   ├── pricingRoutes.js
│   │   └── adminRoutes.js
│   │
│   ├── middleware/
│   │   ├── authMiddleware.js
│   │   ├── errorHandler.js
│   │   ├── validation.js
│   │   └── rateLimiter.js
│   │
│   ├── services/
│   │   ├── bookingService.js
│   │   ├── pricingService.js
│   │   ├── matchingService.js
│   │   ├── trackingService.js
│   │   ├── notificationService.js
│   │   └── analyticsService.js
│   │
│   ├── utils/
│   │   ├── logger.js
│   │   ├── apiResponse.js
│   │   ├── geocoding.js
│   │   └── distanceCalculator.js
│   │
│   ├── websockets/
│   │   ├── trackingSocket.js
│   │   └── notificationSocket.js
│   │
│   ├── jobs/
│   │   ├── cleanupJob.js
│   │   └── analyticsJob.js
│   │
│   └── app.js
│
├── tests/
│   ├── unit/
│   └── integration/
│
├── scripts/
│   ├── seed.js
│   └── deploy.sh
│
├── .env
├── .gitignore
├── package.json
└── README.md

================
File: src/app.js
================
const cors = require('cors');
const dotenv = require("dotenv");
const express = require('express');
const mongoose = require('mongoose');
const cookieParser = require('cookie-parser');
const authRouter = require('./routes/authRouter');
const userRouter = require('./routes/userRoutes');
const driverRouter = require('./routes/driverRoutes');
const vehicleRouter = require('./routes/vehicleRoutes');
const bookingRouter = require('./routes/bookingRoutes');
const errorHandler = require('./middleware/errorHandler.js');

const PORT = process.env.PORT || 3001;
const express = require('express');
const http = require('http');
const setupWebSocket = require('./websockets/trackingSocket');

dotenv.config();
const app = express();
const server = http.createServer(app);
const io = setupWebSocket(server);

app.use(express.json());
app.use(cookieParser());
app.use(cors());
app.use(errorHandler);

app.use("/api/v2/auth", authRouter);
app.use("/api/v2/users", userRouter);
app.use("/api/v2/drivers", driverRouter);
app.use("/api/v2/vehicles", vehicleRouter);
app.use("/api/v2/bookings", bookingRouter);
app.use("/api/v2/admin", adminRouter);

app.get('/', (req, res) => {
  res.send(`
    <h1>Server has started and API is Working</h1>
    <p>Refer to the Postman Docs here: <a href="https://documenter.getpostman.com/view/37397155/2sA3rwLDt1">Postman Documentation</a></p>
  `);
});

const mongoDB = async () => {
  try {
    await mongoose.connect(process.env.MONGO_URL);
    console.log("MongoDB Database connected Successfully!");
  } catch (err) {
    console.log("Failed to connect to MongoDB:", err);
    throw err;
  }
}

app.listen(PORT, () => {
  mongoDB();
  console.log(`Server is running on http://localhost:${PORT}`);
});

module.exports = { app, io };

================
File: src/controllers/adminController.js
================
// src/controllers/adminController.js

const User = require('../models/User');
const Booking = require('../models/Booking');
const Vehicle = require('../models/Vehicle');

exports.getDashboard = async (req, res) => {
  try {
    const userCount = await User.countDocuments();
    const driverCount = await User.countDocuments({ role: 'driver' });
    const bookingCount = await Booking.countDocuments();
    const vehicleCount = await Vehicle.countDocuments();

    res.json({
      success: true,
      data: {
        userCount,
        driverCount,
        bookingCount,
        vehicleCount
      }
    });
  } catch (error) {
    res.status(500).json({ success: false, message: 'Error fetching dashboard data', error: error.message });
  }
};

exports.getStatistics = async (req, res) => {
  try {
    const completedRides = await Booking.countDocuments({ status: 'completed' });
    const cancelledRides = await Booking.countDocuments({ status: 'cancelled' });
    const totalRevenue = await Booking.aggregate([
      { $match: { status: 'completed' } },
      { $group: { _id: null, total: { $sum: '$price' } } }
    ]);

    res.json({
      success: true,
      data: {
        completedRides,
        cancelledRides,
        totalRevenue: totalRevenue[0]?.total || 0
      }
    });
  } catch (error) {
    res.status(500).json({ success: false, message: 'Error fetching statistics', error: error.message });
  }
};

exports.getAllUsers = async (req, res) => {
  try {
    const users = await User.find().select('-password');
    res.json({ success: true, data: users });
  } catch (error) {
    res.status(500).json({ success: false, message: 'Error fetching users', error: error.message });
  }
};

exports.getAllDrivers = async (req, res) => {
  try {
    const drivers = await User.find({ role: 'driver' }).select('-password');
    res.json({ success: true, data: drivers });
  } catch (error) {
    res.status(500).json({ success: false, message: 'Error fetching drivers', error: error.message });
  }
};

exports.getAllVehicles = async (req, res) => {
  try {
    const vehicles = await Vehicle.find().populate('driver', '-password');
    res.json({ success: true, data: vehicles });
  } catch (error) {
    res.status(500).json({ success: false, message: 'Error fetching vehicles', error: error.message });
  }
};

================
File: src/controllers/authController.js
================
const User = require('../models/User');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');
exports.signup = async (req, res) => {
  try {
    const { username, email, password, role, licenseNumber, experienceYears } = req.body;
    
    if (role === 'driver' && (!licenseNumber || !experienceYears)) {
      return res.status(400).json({ success: false, message: 'License number and experience years are required for drivers' });
    }

    const user = new User({ 
      username, 
      email, 
      password, 
      role,
      ...(role === 'driver' && { licenseNumber, experienceYears })
    });
    
    await user.save();
    
    const token = jwt.sign({ id: user._id }, process.env.JWT_SECRET, { expiresIn: '1d' });
    res.cookie('token', token, { httpOnly: true, maxAge: 24 * 60 * 60 * 1000 }); // 1 day

    res.status(201).json({ 
      success: true, 
      user: { 
        id: user._id, 
        username: user.username, 
        email: user.email,
        role: user.role
      } 
    });
  } catch (error) {
    res.status(400).json({ success: false, message: error.message });
  }
};

exports.login = async (req, res) => {
  try {
    const { email, password } = req.body;
    const user = await User.findOne({ email });
    if (!user || !(await bcrypt.compare(password, user.password))) {
      return res.status(401).json({ success: false, message: 'Invalid credentials' });
    }

    const token = jwt.sign({ id: user._id }, process.env.JWT_SECRET, { expiresIn: '1d' });
    res.cookie('token', token, { httpOnly: true, maxAge: 24 * 60 * 60 * 1000 }); // 1 day

    res.status(200).json({ success: true, user: { id: user._id, username: user.username, email: user.email } });
  } catch (error) {
    res.status(400).json({ success: false, message: error.message });
  }
};

exports.logout = (req, res) => {
  res.clearCookie('token');
  res.status(200).json({ success: true, message: 'Logged out successfully' });
};

exports.getMe = async (req, res) => {
  try {
    // The user ID is available from the authentication middleware
    const userId = req.user.id;

    // Fetch the user from the database
    const user = await User.findById(userId).select('-password');

    if (!user) {
      return res.status(404).json({ success: false, message: 'User not found' });
    }

    // Return the user information
    res.status(200).json({
      success: true,
      user: {
        id: user._id,
        username: user.username,
        email: user.email
        // Add any other fields you want to return
      }
    });
  } catch (error) {
    res.status(500).json({ success: false, message: 'Error fetching user data', error: error.message });
  }
};

================
File: src/controllers/bookingController.js
================
const Booking = require('../models/Booking');
const User = require('../models/User');
const Vehicle = require('../models/Vehicle');
const trackingService = require('../services/trackingService');

exports.getAllBookings = async (req, res) => {
  try {
    const bookings = await Booking.find()
      .populate('user', '-password')
      .populate('driver', '-password')
      .populate('vehicle');
    res.status(200).json({ success: true, bookings });
  } catch (error) {
    res.status(500).json({ success: false, message: 'Error fetching bookings', error: error.message });
  }
};

exports.getBookingById = async (req, res) => {
  try {
    const booking = await Booking.findById(req.params.id)
      .populate('user', '-password')
      .populate('driver', '-password')
      .populate('vehicle');
    if (!booking) {
      return res.status(404).json({ success: false, message: 'Booking not found' });
    }
    res.status(200).json({ success: true, booking });
  } catch (error) {
    res.status(500).json({ success: false, message: 'Error fetching booking', error: error.message });
  }
};

exports.createBooking = async (req, res) => {
    try {
      const { userId, driverId, vehicleId, pickup, dropoff, price } = req.body;
  
      console.log('Creating booking with:', { userId, driverId, vehicleId, pickup, dropoff, price });
  
      // Check if user exists
      const user = await User.findById(userId);
      if (!user) {
        console.log('User not found:', userId);
        return res.status(400).json({ success: false, message: 'Invalid user' });
      }
  
      // Check if driver exists and is actually a driver
      const driver = await User.findOne({ _id: driverId });

      if (!driver) {
        console.log('Driver not found or not a driver:', driverId);
        return res.status(400).json({ success: false, message: 'Invalid driver' });
      }
  
      // Check if vehicle exists and belongs to the driver
      const vehicle = await Vehicle.findOne({ _id: vehicleId, driver: driverId });
      if (!vehicle) {
        console.log('Vehicle not found or does not belong to driver:', vehicleId, driverId);
        return res.status(400).json({ success: false, message: 'Invalid vehicle or vehicle does not belong to the driver' });
      }
      console.log("Driver Id is : ", driverId);

      const booking = new Booking({
        user: userId,
        driver: driverId,
        vehicle: vehicleId,
        pickup,
        dropoff,
        price,
        status: 'pending'
      });
  
      await booking.save();
      console.log('Booking saved:', booking);
  
      // Update driver and vehicle availability
      await User.findByIdAndUpdate(driverId, { isAvailable: false });
      await Vehicle.findByIdAndUpdate(vehicleId, { isAvailable: false });
  
      // Fetch the saved booking with populated fields
      const populatedBooking = await Booking.findById(booking._id)
        .populate('user', '-password')
        .populate('driver', '-password')
        .populate('vehicle');
  
      console.log('Populated booking:', populatedBooking);
  
      res.status(201).json({ success: true, booking: populatedBooking });
    } catch (error) {
      console.error('Error creating booking:', error);
      res.status(400).json({ success: false, message: 'Error creating booking', error: error.message });
    }
  };

exports.updateBookingStatus = async (req, res) => {
  try {
    const { status } = req.body;
    const booking = await Booking.findByIdAndUpdate(
      req.params.id,
      { status },
      { new: true, runValidators: true }
    )
      .populate('user', '-password')
      .populate('driver', '-password')
      .populate('vehicle');

    if (!booking) {
      return res.status(404).json({ success: false, message: 'Booking not found' });
    }

    // If the booking is completed or cancelled, make the driver and vehicle available again
    if (status === 'completed' || status === 'cancelled') {
      await User.findByIdAndUpdate(booking.driver._id, { isAvailable: true });
      await Vehicle.findByIdAndUpdate(booking.vehicle._id, { isAvailable: true });
    }

    res.status(200).json({ success: true, booking });
  } catch (error) {
    res.status(400).json({ success: false, message: 'Error updating booking status', error: error.message });
  }
};

exports.deleteBooking = async (req, res) => {
  try {
    const booking = await Booking.findById(req.params.id);
    if (!booking) {
      return res.status(404).json({ success: false, message: 'Booking not found' });
    }
    
    // Make the driver and vehicle available again
    await User.findByIdAndUpdate(booking.driver, { isAvailable: true });
    await Vehicle.findByIdAndUpdate(booking.vehicle, { isAvailable: true });

    await Booking.findByIdAndDelete(req.params.id);

    res.status(200).json({ success: true, message: 'Booking deleted successfully' });
  } catch (error) {
    res.status(500).json({ success: false, message: 'Error deleting booking', error: error.message });
  }
};

exports.startTracking = async (req, res) => {
  try {
    const { id } = req.params;
    const booking = await Booking.findById(id);
    if (!booking) {
      return res.status(404).json({ success: false, message: 'Booking not found' });
    }
    
    // Initialize tracking
    await trackingService.updateLocation(id, { lat: 0, lng: 0 });
    
    res.status(200).json({ success: true, message: 'Tracking started' });
  } catch (error) {
    res.status(500).json({ success: false, message: 'Error starting tracking', error: error.message });
  }
};

exports.getLocation = async (req, res) => {
  try {
    const { id } = req.params;
    const location = await trackingService.getLocation(id);
    if (!location) {
      return res.status(404).json({ success: false, message: 'Location not found' });
    }
    res.status(200).json({ success: true, location });
  } catch (error) {
    res.status(500).json({ success: false, message: 'Error fetching location', error: error.message });
  }
};

module.exports = exports;

================
File: src/controllers/driverController.js
================
const Driver = require('../models/Driver');
const User = require('../models/User');

exports.getAllDrivers = async (req, res) => {
    try {
      const drivers = await User.find({ role: 'driver' }).select('-password');
      res.status(200).json({ success: true, drivers });
    } catch (error) {
      res.status(500).json({ success: false, message: 'Error fetching drivers', error: error.message });
    }
  };

exports.getDriverById = async (req, res) => {
  try {
    const driver = await Driver.findById(req.params.id).populate('user', '-password');
    if (!driver) {
      return res.status(404).json({ success: false, message: 'Driver not found' });
    }
    res.status(200).json({ success: true, driver });
  } catch (error) {
    res.status(500).json({ success: false, message: 'Error fetching driver', error: error.message });
  }
};

exports.createDriver = async (req, res) => {
  try {
    const { userId, licenseNumber, experienceYears } = req.body;

    // Check if user exists
    const user = await User.findById(userId);
    if (!user) {
      return res.status(400).json({ success: false, message: 'Invalid user' });
    }

    const driver = new Driver({
      user: userId,
      licenseNumber,
      experienceYears
    });

    await driver.save();
    res.status(201).json({ success: true, driver });
  } catch (error) {
    res.status(400).json({ success: false, message: 'Error creating driver', error: error.message });
  }
};

exports.updateDriver = async (req, res) => {
  try {
    const driver = await Driver.findByIdAndUpdate(req.params.id, req.body, { new: true, runValidators: true }).populate('user', '-password');
    if (!driver) {
      return res.status(404).json({ success: false, message: 'Driver not found' });
    }
    res.status(200).json({ success: true, driver });
  } catch (error) {
    res.status(400).json({ success: false, message: 'Error updating driver', error: error.message });
  }
};

exports.deleteDriver = async (req, res) => {
  try {
    const driver = await Driver.findByIdAndDelete(req.params.id);
    if (!driver) {
      return res.status(404).json({ success: false, message: 'Driver not found' });
    }
    res.status(200).json({ success: true, message: 'Driver deleted successfully' });
  } catch (error) {
    res.status(500).json({ success: false, message: 'Error deleting driver', error: error.message });
  }
};

exports.updateDriverLocation = async (req, res) => {
    try {
      const { latitude, longitude } = req.body;
      const driver = await User.findOneAndUpdate(
        { _id: req.params.id, role: 'driver' },
        { 
          currentLocation: {
            type: 'Point',
            coordinates: [longitude, latitude]
          }
        },
        { new: true, runValidators: true }
      ).select('-password');
  
      if (!driver) {
        return res.status(404).json({ success: false, message: 'Driver not found' });
      }
      res.status(200).json({ success: true, driver });
    } catch (error) {
      res.status(400).json({ success: false, message: 'Error updating driver location', error: error.message });
    }
  };

exports.getAvailableDrivers = async (req, res) => {
    try {
      const drivers = await User.find({ role: 'driver', isAvailable: true }).select('-password');
      res.status(200).json({ success: true, drivers });
    } catch (error) {
      res.status(500).json({ success: false, message: 'Error fetching available drivers', error: error.message });
    }
  };

  exports.updateDriverAvailability = async (req, res) => {
    try {
      const { isAvailable } = req.body;
      const driver = await User.findOneAndUpdate(
        { _id: req.params.id, role: 'driver' },
        { isAvailable },
        { new: true, runValidators: true }
      ).select('-password');
  
      if (!driver) {
        return res.status(404).json({ success: false, message: 'Driver not found' });
      }
      res.status(200).json({ success: true, driver });
    } catch (error) {
      res.status(400).json({ success: false, message: 'Error updating driver availability', error: error.message });
    }
  };

module.exports = exports;

================
File: src/controllers/userController.js
================
const User = require('../models/User');

exports.getAllUsers = async (req, res) => {
  try {
    const users = await User.find().select('-password');
    res.status(200).json({ success: true, users });
  } catch (error) {
    res.status(500).json({ success: false, message: 'Error fetching users', error: error.message });
  }
};

exports.getUserById = async (req, res) => {
  try {
    const user = await User.findById(req.params.id).select('-password');
    if (!user) {
      return res.status(404).json({ success: false, message: 'User not found' });
    }
    res.status(200).json({ success: true, user });
  } catch (error) {
    res.status(500).json({ success: false, message: 'Error fetching user', error: error.message });
  }
};

exports.updateUser = async (req, res) => {
  try {
    const { username, email } = req.body;
    const user = await User.findByIdAndUpdate(
      req.params.id,
      { username, email },
      { new: true, runValidators: true }
    ).select('-password');

    if (!user) {
      return res.status(404).json({ success: false, message: 'User not found' });
    }

    res.status(200).json({ success: true, user });
  } catch (error) {
    res.status(400).json({ success: false, message: 'Error updating user', error: error.message });
  }
};

exports.deleteUser = async (req, res) => {
  try {
    const user = await User.findByIdAndDelete(req.params.id);
    if (!user) {
      return res.status(404).json({ success: false, message: 'User not found' });
    }
    res.status(200).json({ success: true, message: 'User deleted successfully' });
  } catch (error) {
    res.status(500).json({ success: false, message: 'Error deleting user', error: error.message });
  }
};

================
File: src/controllers/vehicleController.js
================
const Vehicle = require('../models/Vehicle');
const Driver = require('../models/Driver');
const User = require('../models/User');

exports.getAllVehicles = async (req, res) => {
  try {
    const vehicles = await Vehicle.find().populate('driver');
    res.status(200).json({ success: true, vehicles });
  } catch (error) {
    res.status(500).json({ success: false, message: 'Error fetching vehicles', error: error.message });
  }
};

exports.getVehicleById = async (req, res) => {
  try {
    const vehicle = await Vehicle.findById(req.params.id).populate('driver');
    if (!vehicle) {
      return res.status(404).json({ success: false, message: 'Vehicle not found' });
    }
    res.status(200).json({ success: true, vehicle });
  } catch (error) {
    res.status(500).json({ success: false, message: 'Error fetching vehicle', error: error.message });
  }
};
exports.getVehiclesByDriver = async (req, res) => {
    try {
      const driverId = req.params.driverId;
  
      // Check if the driver exists
      const driver = await User.findOne({ _id: driverId, role: 'driver' });
      if (!driver) {
        return res.status(404).json({ success: false, message: 'Driver not found' });
      }
  
      // Find all vehicles associated with this driver
      const vehicles = await Vehicle.find({ driver: driverId });
  
      res.status(200).json({ success: true, vehicles });
    } catch (error) {
      res.status(500).json({ success: false, message: 'Error fetching vehicles', error: error.message });
    }
  };
  
exports.createVehicle = async (req, res) => {
    try {
      const { driverId, make, model, year, licensePlate, vehicleType, capacity, color } = req.body;
  
      // Check if driver exists and is actually a driver
      const driver = await User.findOne({ _id: driverId, role: 'driver' });
      if (!driver) {
        return res.status(400).json({ success: false, message: 'Invalid driver' });
      }
  
      const vehicle = new Vehicle({
        driver: driverId,
        make,
        model,
        year,
        licensePlate,
        vehicleType,
        capacity,
        color
      });
  
      await vehicle.save();
      res.status(201).json({ success: true, vehicle });
    } catch (error) {
      res.status(400).json({ success: false, message: 'Error creating vehicle', error: error.message });
    }
  };

exports.updateVehicle = async (req, res) => {
  try {
    const vehicle = await Vehicle.findByIdAndUpdate(req.params.id, req.body, { new: true, runValidators: true }).populate('driver');
    if (!vehicle) {
      return res.status(404).json({ success: false, message: 'Vehicle not found' });
    }
    res.status(200).json({ success: true, vehicle });
  } catch (error) {
    res.status(400).json({ success: false, message: 'Error updating vehicle', error: error.message });
  }
};

exports.deleteVehicle = async (req, res) => {
  try {
    const vehicle = await Vehicle.findByIdAndDelete(req.params.id);
    if (!vehicle) {
      return res.status(404).json({ success: false, message: 'Vehicle not found' });
    }
    res.status(200).json({ success: true, message: 'Vehicle deleted successfully' });
  } catch (error) {
    res.status(500).json({ success: false, message: 'Error deleting vehicle', error: error.message });
  }
};

exports.getAvailableVehicles = async (req, res) => {
  try {
    const vehicles = await Vehicle.find({ isAvailable: true }).populate('driver');
    res.status(200).json({ success: true, vehicles });
  } catch (error) {
    res.status(500).json({ success: false, message: 'Error fetching available vehicles', error: error.message });
  }
};

module.exports = exports;

================
File: src/middleware/adminMiddleware.js
================
const User = require('../models/User');

exports.isAdmin = async (req, res, next) => {
  try {
    const user = await User.findById(req.user.id);
    if (user.role !== 'admin') {
      return res.status(403).json({ success: false, message: 'Access denied. Admin only.' });
    }
    next();
  } catch (error) {
    res.status(500).json({ success: false, message: 'Error checking admin status', error: error.message });
  }
};

================
File: src/middleware/authMiddleware.js
================
const jwt = require('jsonwebtoken');

const authentication = async (req, res, next) => {
  try {
    const token =
      req.cookies.token ||
      req.body.token ||
      (req.header("Authorization") ? req.header("Authorization").replace("Bearer ", "") : null);

    if (!token) {
      return res.status(401).json({ success: false, message: "Token Not Found" });
    }

    try {
      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      req.user = decoded;
      next();
    } catch (err) {
      return res.status(401).json({ success: false, message: "Invalid token" });
    }
  } catch (err) {
    return res.status(401).json({
      success: false,
      message: "Something went wrong while validating token",
    });
  }
};


module.exports = { authentication };

================
File: src/middleware/errorHandler.js
================
// src/middleware/errorMiddleware.js

const errorHandler = (err, req, res, next) => {
    console.error(err.stack);
    res.status(500).json({
      success: false,
      message: 'An unexpected error occurred',
      error: process.env.NODE_ENV === 'production' ? {} : err
    });
  };
  
  module.exports = errorHandler;

================
File: src/models/Booking.js
================
const mongoose = require('mongoose');

const bookingSchema = new mongoose.Schema({
  user: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  driver: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',  // or 'Driver' if you decide to use the separate Driver model
    required: true
  },
  vehicle: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Vehicle',
    required: true
  },
  pickup: {
    address: { type: String, required: true },
    coordinates: {
      lat: { type: Number, required: true },
      lng: { type: Number, required: true }
    }
  },
  dropoff: {
    address: { type: String, required: true },
    coordinates: {
      lat: { type: Number, required: true },
      lng: { type: Number, required: true }
    }
  },
  status: {
    type: String,
    enum: ['pending', 'accepted', 'in_progress', 'completed', 'cancelled'],
    default: 'pending'
  },
  price: {
    type: Number,
    required: true
  },
  startTime: Date,
  endTime: Date,
  createdAt: {
    type: Date,
    default: Date.now
  }
});

module.exports = mongoose.model('Booking', bookingSchema);

================
File: src/models/Driver.js
================
const mongoose = require('mongoose');

const driverSchema = new mongoose.Schema({
  user: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  licenseNumber: {
    type: String,
    required: true,
    unique: true
  },
  experienceYears: {
    type: Number,
    required: true
  },
  rating: {
    type: Number,
    default: 0,
    min: 0,
    max: 5
  },
  isAvailable: {
    type: Boolean,
    default: true
  },
  currentLocation: {
    type: {
      type: String,
      enum: ['Point'],
      default: 'Point'
    },
    coordinates: {
      type: [Number],
      default: [0, 0]
    }
  },
  createdAt: {
    type: Date,
    default: Date.now
  }
});

driverSchema.index({ currentLocation: '2dsphere' });

module.exports = mongoose.model('Driver', driverSchema);

================
File: src/models/User.js
================
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');

const userSchema = new mongoose.Schema({
  username: { type: String, required: true, unique: true },
  email: { type: String, required: true, unique: true },
  password: { type: String, required: true },
  role: { type: String, enum: ['customer', 'driver', 'admin'], default: 'customer' },
  // Fields for drivers
  licenseNumber: { type: String, unique: true, sparse: true },
  experienceYears: { type: Number },
  isAvailable: { type: Boolean, default: false },
  currentLocation: {
    type: {
      type: String,
      enum: ['Point'],
      default: 'Point'
    },
    coordinates: {
      type: [Number],
      default: [0, 0]
    }
  },
  // Common fields
  phoneNumber: { type: String },
  address: { type: String },
});

userSchema.pre('save', async function(next) {
  if (this.isModified('password')) {
    this.password = await bcrypt.hash(this.password, 10);
  }
  next();
});

userSchema.index({ currentLocation: '2dsphere' });

module.exports = mongoose.model('User', userSchema);

================
File: src/models/Vehicle.js
================
const mongoose = require('mongoose');

const vehicleSchema = new mongoose.Schema({
  driver: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Driver',
    required: true
  },
  make: {
    type: String,
    required: true
  },
  model: {
    type: String,
    required: true
  },
  year: {
    type: Number,
    required: true
  },
  licensePlate: {
    type: String,
    required: true,
    unique: true
  },
  vehicleType: {
    type: String,
    enum: ['sedan', 'suv', 'van', 'truck'],
    required: true
  },
  capacity: {
    type: Number,
    required: true
  },
  color: String,
  isAvailable: {
    type: Boolean,
    default: true
  },
  createdAt: {
    type: Date,
    default: Date.now
  }
});

module.exports = mongoose.model('Vehicle', vehicleSchema);

================
File: src/routes/adminRoutes.js
================
// src/routes/adminRoutes.js

const express = require('express');
const router = express.Router();
const adminController = require('../controllers/adminController');
const { authentication } = require('../middleware/authMiddleware');
const { isAdmin } = require('../middleware/adminMiddleware');

router.use(authentication);
router.use(isAdmin);

router.get('/dashboard', adminController.getDashboard);
router.get('/statistics', adminController.getStatistics);
router.get('/users', adminController.getAllUsers);
router.get('/drivers', adminController.getAllDrivers);
router.get('/vehicles', adminController.getAllVehicles);

module.exports = router;

================
File: src/routes/authRouter.js
================
const express = require('express');
const router = express.Router();
const authController = require('../controllers/authController');
const { authentication } = require('../middleware/authMiddleware');


router.post('/signup', authController.signup);
router.post('/login', authController.login);
router.get('/logout', authController.logout);
router.get('/me', authentication, authController.getMe);

module.exports = router;

================
File: src/routes/bookingRoutes.js
================
const express = require('express');
const router = express.Router();
const bookingController = require('../controllers/bookingController');
const { authentication } = require('../middleware/authMiddleware');

router.use(authentication);

router.get('/', bookingController.getAllBookings);
router.get('/:id', bookingController.getBookingById);
router.post('/', bookingController.createBooking);
router.put('/:id/status', bookingController.updateBookingStatus);
router.delete('/:id', bookingController.deleteBooking);
router.post('/:id/track', bookingController.startTracking);
router.get('/:id/location', bookingController.getLocation);

module.exports = router;

================
File: src/routes/driverRoutes.js
================
const express = require('express');
const router = express.Router();
const driverController = require('../controllers/driverController');
const { authentication } = require('../middleware/authMiddleware');

router.use(authentication);

router.get('/', driverController.getAllDrivers);
router.get('/available', driverController.getAvailableDrivers);
router.get('/:id', driverController.getDriverById);
router.post('/', driverController.createDriver);
router.put('/:id', driverController.updateDriver);
router.put('/:id/location', driverController.updateDriverLocation);
router.put('/:id/availability', driverController.updateDriverAvailability);
router.delete('/:id', driverController.deleteDriver);

module.exports = router;

================
File: src/routes/userRoutes.js
================
const express = require('express');
const router = express.Router();
const userController = require('../controllers/userController');
const { authentication } = require('../middleware/authMiddleware');

// Apply authentication middleware to all routes
router.use(authentication);

router.get('/', userController.getAllUsers);
router.get('/:id', userController.getUserById);
router.put('/:id', userController.updateUser);
router.delete('/:id', userController.deleteUser);

module.exports = router;

================
File: src/routes/vehicleRoutes.js
================
const express = require('express');
const router = express.Router();
const vehicleController = require('../controllers/vehicleController');
const { authentication } = require('../middleware/authMiddleware');

router.use(authentication);

router.get('/', vehicleController.getAllVehicles);
router.get('/available', vehicleController.getAvailableVehicles);
router.get('/:id', vehicleController.getVehicleById);
router.post('/', vehicleController.createVehicle);
router.put('/:id', vehicleController.updateVehicle);
router.delete('/:id', vehicleController.deleteVehicle);
router.get('/driver/:driverId', vehicleController.getVehiclesByDriver);
module.exports = router;

================
File: src/services/pricingService.js
================
const calculatePrice = (distance, duration, basePrice = 5, pricePerKm = 1.5, pricePerMinute = 0.5) => {
    const distancePrice = distance * pricePerKm;
    const timePrice = duration * pricePerMinute;
    return basePrice + distancePrice + timePrice;
  };
  
  module.exports = { calculatePrice };

================
File: src/services/trackingService.js
================
// src/services/trackingService.js

const redis = require('redis');
const { promisify } = require('util');

const redisClient = redis.createClient(process.env.REDIS_URL);
const getAsync = promisify(redisClient.get).bind(redisClient);
const setAsync = promisify(redisClient.set).bind(redisClient);

exports.updateLocation = async (bookingId, location) => {
  await setAsync(`location:${bookingId}`, JSON.stringify(location));
};

exports.getLocation = async (bookingId) => {
  const locationString = await getAsync(`location:${bookingId}`);
  return JSON.parse(locationString);
};

================
File: src/websockets/trackingSocket.js
================
// src/websockets/trackingSocket.js

const socketIo = require('socket.io');
const redis = require('redis');
const { promisify } = require('util');

const redisClient = redis.createClient(process.env.REDIS_URL);
const getAsync = promisify(redisClient.get).bind(redisClient);
const setAsync = promisify(redisClient.set).bind(redisClient);

function setupWebSocket(server) {
  const io = socketIo(server);

  io.on('connection', (socket) => {
    console.log('New client connected');

    socket.on('subscribe', (bookingId) => {
      socket.join(bookingId);
    });

    socket.on('unsubscribe', (bookingId) => {
      socket.leave(bookingId);
    });

    socket.on('updateLocation', async ({ bookingId, location }) => {
      await setAsync(`location:${bookingId}`, JSON.stringify(location));
      io.to(bookingId).emit('locationUpdate', location);
    });

    socket.on('disconnect', () => {
      console.log('Client disconnected');
    });
  });

  return io;
}

module.exports = setupWebSocket;

================
File: test.js
================
// test-redis.js

const redis = require('redis');
const { promisify } = require('util');

const client = redis.createClient();

client.on('error', (err) => console.log('Redis Client Error', err));

const setAsync = promisify(client.set).bind(client);
const getAsync = promisify(client.get).bind(client);

async function testRedis() {
  try {
    await setAsync('testKey', 'Hello, Redis!');
    const value = await getAsync('testKey');
    console.log('Retrieved value:', value);
  } catch (error) {
    console.error('Error:', error);
  } finally {
    client.quit();
  }
}

testRedis();
