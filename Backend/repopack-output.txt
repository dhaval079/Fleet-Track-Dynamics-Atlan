This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-10-14T17:26:50.105Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
.gitignore
package.json
README.md
src/app.js
src/controllers/authController.js
src/middleware/authMiddleware.js
src/models/User.js
src/routes/authRouter.js

================================================================
Repository Files
================================================================

================
File: .gitignore
================
echo "node_modules/
.env
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.DS_Store" > .gitignore

================
File: package.json
================
{
  "name": "atlan-backend",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start": "node src/app.js",
    "dev": "nodemon src/app.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "bcrypt": "^5.1.1",
    "bcryptjs": "^2.4.3",
    "body-parser": "^1.20.3",
    "cookie-parser": "^1.4.7",
    "cors": "^2.8.5",
    "dotenv": "^16.4.5",
    "express": "^4.21.1",
    "express-async-handler": "^1.2.0",
    "json2csv": "^6.0.0-alpha.2",
    "jsonwebtoken": "^9.0.2",
    "mongoose": "^8.7.1",
    "node": "^20.18.0",
    "repopack": "^0.1.42"
  },
  "devDependencies": {
    "nodemon": "^3.1.7"
  }
}

================
File: README.md
================
# Project Structure
backend/
│
├── src/
│   ├── config/
│   │   ├── database.js
│   │   ├── environment.js
│   │   └── redis.js
│   │
│   ├── controllers/
│   │   ├── authController.js
│   │   ├── userController.js
│   │   ├── driverController.js
│   │   ├── bookingController.js
│   │   ├── vehicleController.js
│   │   ├── trackingController.js
│   │   ├── pricingController.js
│   │   └── adminController.js
│   │
│   ├── models/
│   │   ├── User.js
│   │   ├── Driver.js
│   │   ├── Booking.js
│   │   ├── Vehicle.js
│   │   ├── Location.js
│   │   └── Payment.js
│   │
│   ├── routes/
│   │   ├── authRoutes.js
│   │   ├── userRoutes.js
│   │   ├── driverRoutes.js
│   │   ├── bookingRoutes.js
│   │   ├── vehicleRoutes.js
│   │   ├── trackingRoutes.js
│   │   ├── pricingRoutes.js
│   │   └── adminRoutes.js
│   │
│   ├── middleware/
│   │   ├── authMiddleware.js
│   │   ├── errorHandler.js
│   │   ├── validation.js
│   │   └── rateLimiter.js
│   │
│   ├── services/
│   │   ├── bookingService.js
│   │   ├── pricingService.js
│   │   ├── matchingService.js
│   │   ├── trackingService.js
│   │   ├── notificationService.js
│   │   └── analyticsService.js
│   │
│   ├── utils/
│   │   ├── logger.js
│   │   ├── apiResponse.js
│   │   ├── geocoding.js
│   │   └── distanceCalculator.js
│   │
│   ├── websockets/
│   │   ├── trackingSocket.js
│   │   └── notificationSocket.js
│   │
│   ├── jobs/
│   │   ├── cleanupJob.js
│   │   └── analyticsJob.js
│   │
│   └── app.js
│
├── tests/
│   ├── unit/
│   └── integration/
│
├── scripts/
│   ├── seed.js
│   └── deploy.sh
│
├── .env
├── .gitignore
├── package.json
└── README.md

================
File: src/app.js
================
const cors = require('cors');
const dotenv = require("dotenv");
const express = require('express');
const mongoose = require('mongoose');
const cookieParser = require('cookie-parser');
const authRouter = require('./routes/authRouter');

const PORT = process.env.PORT || 3001;
dotenv.config();
const app = express();
app.use(express.json());
app.use(cookieParser());
app.use(cors());
app.use("/api/v2/", authRouter);
// app.use("/api/v2/locations", locationRouter);
// app.use("/api/v2/roads", roadRouter);
// app.use("/api/v2/traffic", trafficRouter);
// app.use("/api/v2/shortest-path", shortestPathRouter);
// app.use("/api/v2/traffic-conditions", trafficConditionRouter);

app.get('/', (req, res) => {
    res.send(`
      <h1>Server has started and API is Working</h1>
      <p>Refer to the Postman Docs here: <a href="https://documenter.getpostman.com/view/37397155/2sA3rwLDt1">Postman Documentation</a></p>
    `);
  });
  
  const mongoDB = async () => {
    try {
      await mongoose.connect(process.env.MONGO_URL);
      console.log("MongoDB Database connected Successfully!");
    } catch (err) {
      console.log("Failed to connect to MongoDB:", err);
      throw err;
    }
  }
  
  app.listen(PORT, () => {
    mongoDB();
    console.log(`Server is running on http://localhost:${PORT}`);
  });

================
File: src/controllers/authController.js
================
const User = require('../models/User');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');

exports.signup = async (req, res) => {
  try {
    const { username, email, password } = req.body;
    const user = new User({ username, email, password });
    await user.save();
    
    const token = jwt.sign({ id: user._id }, process.env.JWT_SECRET, { expiresIn: '1d' });
    res.cookie('token', token, { httpOnly: true, maxAge: 24 * 60 * 60 * 1000 }); // 1 day

    res.status(201).json({ success: true, user: { id: user._id, username: user.username, email: user.email } });
  } catch (error) {
    res.status(400).json({ success: false, message: error.message });
  }
};

exports.login = async (req, res) => {
  try {
    const { email, password } = req.body;
    const user = await User.findOne({ email });
    if (!user || !(await bcrypt.compare(password, user.password))) {
      return res.status(401).json({ success: false, message: 'Invalid credentials' });
    }

    const token = jwt.sign({ id: user._id }, process.env.JWT_SECRET, { expiresIn: '1d' });
    res.cookie('token', token, { httpOnly: true, maxAge: 24 * 60 * 60 * 1000 }); // 1 day

    res.status(200).json({ success: true, user: { id: user._id, username: user.username, email: user.email } });
  } catch (error) {
    res.status(400).json({ success: false, message: error.message });
  }
};

exports.logout = (req, res) => {
  res.clearCookie('token');
  res.status(200).json({ success: true, message: 'Logged out successfully' });
};

exports.getMe = async (req, res) => {
  try {
    // The user ID is available from the authentication middleware
    const userId = req.user.id;

    // Fetch the user from the database
    const user = await User.findById(userId).select('-password');

    if (!user) {
      return res.status(404).json({ success: false, message: 'User not found' });
    }

    // Return the user information
    res.status(200).json({
      success: true,
      user: {
        id: user._id,
        username: user.username,
        email: user.email
        // Add any other fields you want to return
      }
    });
  } catch (error) {
    res.status(500).json({ success: false, message: 'Error fetching user data', error: error.message });
  }
};

================
File: src/middleware/authMiddleware.js
================
const jwt = require('jsonwebtoken');

const authentication = async (req, res, next) => {
  try {
    const token =
      req.cookies.token ||
      req.body.token ||
      (req.header("Authorization") ? req.header("Authorization").replace("Bearer ", "") : null);

    if (!token) {
      return res.status(401).json({ success: false, message: "Token Not Found" });
    }

    try {
      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      req.user = decoded;
      next();
    } catch (err) {
      return res.status(401).json({ success: false, message: "Invalid token" });
    }
  } catch (err) {
    return res.status(401).json({
      success: false,
      message: "Something went wrong while validating token",
    });
  }
};


module.exports = { authentication };

================
File: src/models/User.js
================
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');

const userSchema = new mongoose.Schema({
  username: { type: String, required: true, unique: true },
  email: { type: String, required: true, unique: true },
  password: { type: String, required: true },
});

userSchema.pre('save', async function(next) {
  if (this.isModified('password')) {
    this.password = await bcrypt.hash(this.password, 10);
  }
  next();
});

module.exports = mongoose.model('User', userSchema);

================
File: src/routes/authRouter.js
================
const express = require('express');
const router = express.Router();
const authController = require('../controllers/authController');
const { authentication } = require('../middleware/authMiddleware');


router.post('/signup', authController.signup);
router.post('/login', authController.login);
router.get('/logout', authController.logout);
router.get('/me', authentication, authController.getMe);

module.exports = router;
